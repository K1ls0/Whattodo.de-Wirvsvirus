import _defineProperty from '@babel/runtime/helpers/defineProperty';
import PropTypes from 'prop-types';
import ReactDOM, { createPortal } from 'react-dom';
import { noop, mergeDeepRightAll, rejectNil, isFunction } from 'ramda-extension';
import React, { createContext, Component, Fragment } from 'react';
import { o, unary, prop, applySpec, path, map, ifElse, contains, always, curry, find, whereEq, memoizeWith } from 'ramda';
import _extends from '@babel/runtime/helpers/extends';
import hoistNonReactStatics from 'hoist-non-react-statics';
import _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var RouteShape = {
  component: PropTypes.elementType.isRequired,
  path: PropTypes.string.isRequired
};
var WidgetDescriptorShape = {
  container: PropTypes.string,
  data: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  namespace: PropTypes.string,
  widget: PropTypes.string.isRequired
};
var WidgetConfigShape = _objectSpread({}, WidgetDescriptorShape, {
  component: PropTypes.elementType.isRequired,
  // NOTE: We added `isRequired` to avoid using `namespace || container` everywhere.
  namespace: PropTypes.string.isRequired
});

var INVALID_JSON = 'INVALID_JSON';
var IS_SERVER = Boolean(process && process.versions && process.versions.node);
var SHOULD_NOT_LEAK = process.env.NODE_ENV === 'production' && !IS_SERVER;
var RESCAN = 'react-union/rescan';

var DEFAULT_UNION_ROOT_ID = 'union';

var createElement = function createElement(id, parent, elementType) {
  var newElement = document.createElement(elementType);
  var idAttribute = document.createAttribute('id');
  idAttribute.value = id;
  newElement.setAttributeNode(idAttribute);
  parent.appendChild(newElement);
  return newElement;
};

var createElementWithId = function createElementWithId(id, parent, elementType) {
  if (elementType === void 0) {
    elementType = 'div';
  }

  var element = document.getElementById(id);
  return element ? element : createElement(id, parent, elementType);
};

function justRender(reactElement, rootId, resolve) {
  if (rootId === void 0) {
    rootId = DEFAULT_UNION_ROOT_ID;
  }

  if (resolve === void 0) {
    resolve = noop;
  }

  var domElement = createElementWithId(rootId, document.body);

  if (window.__HYDRATE__) {
    // NOTE: We do not want to hydrate twice.
    delete window.__HYDRATE__; // TODO: Use ReactDOM.hydrate once React supports hydration of portals.
    // https://github.com/facebook/react/issues/13097

    ReactDOM.render(reactElement, domElement, resolve);
  }

  ReactDOM.render(reactElement, domElement, resolve);
}
function justUnmountComponentAtNode(rootId) {
  if (rootId === void 0) {
    rootId = DEFAULT_UNION_ROOT_ID;
  }

  var rootElement = document.getElementById(rootId);
  ReactDOM.unmountComponentAtNode(rootElement);
}
var rescan = function rescan() {
  var event = document.createEvent('Event');
  event.initEvent(RESCAN, true, true);
  document.dispatchEvent(event);
};

var WidgetContext = createContext({
  data: undefined,
  namespace: undefined
});
var PrescanContext = createContext({
  initialProps: undefined,
  widgetConfigs: undefined
});

var selectWidgetDescriptorElements = function selectWidgetDescriptorElements(parent) {
  return parent.querySelectorAll('[data-union-widget]');
};

var selectCommonDescriptorElements = function selectCommonDescriptorElements(parent) {
  return parent.querySelectorAll('[data-union-common]');
};

var dangerouslyParseJSONContent = o(unary(JSON.parse), prop('innerHTML'));

var parseJSONContent = function parseJSONContent(element) {
  try {
    return dangerouslyParseJSONContent(element);
  } catch (error) {
    if (element.innerHTML.trim()) {
      return INVALID_JSON;
    }

    return null;
  }
};

var parseWidgetDescriptorElement = applySpec({
  widget: path(['dataset', 'unionWidget']),
  container: path(['dataset', 'unionContainer']),
  namespace: path(['dataset', 'unionNamespace']),
  data: parseJSONContent
});
var getWidgetDescriptors = o(map(parseWidgetDescriptorElement), selectWidgetDescriptorElements);
var parseCommonDescriptorElement = applySpec({
  data: parseJSONContent
});
var getCommonDescriptors = o(map(parseCommonDescriptorElement), selectCommonDescriptorElements);

var DOM = /*#__PURE__*/Object.freeze({
getWidgetDescriptors: getWidgetDescriptors,
getCommonDescriptors: getCommonDescriptors
});

var dangerouslyParseJSONContent$1 = o(unary(JSON.parse), function (wrapper) {
  return wrapper.html();
});

var parseJSONContent$1 = function parseJSONContent(wrapper) {
  try {
    return dangerouslyParseJSONContent$1(wrapper);
  } catch (error) {
    if (wrapper.html().trim()) {
      return INVALID_JSON;
    }

    return null;
  }
};

var parseWidgetDescriptorWrapper = function parseWidgetDescriptorWrapper(wrapper) {
  return {
    widget: wrapper.data('union-widget'),
    container: wrapper.data('union-container'),
    namespace: wrapper.data('union-namespace'),
    data: parseJSONContent$1(wrapper)
  };
};

var getWidgetDescriptors$1 = function getWidgetDescriptors($) {
  return $('[data-union-widget]').map(function (_, element) {
    return parseWidgetDescriptorWrapper($(element));
  }).get();
};
var parseCommonDescriptorWrapper = applySpec({
  data: parseJSONContent$1
});
var getCommonDescriptors$1 = function getCommonDescriptors($) {
  return $('[data-union-common]').map(function (_, element) {
    return parseCommonDescriptorWrapper($(element));
  }).get();
};

var Cheerio = /*#__PURE__*/Object.freeze({
getWidgetDescriptors: getWidgetDescriptors$1,
getCommonDescriptors: getCommonDescriptors$1
});

var _ref = IS_SERVER ? Cheerio : DOM,
    getWidgetDescriptors$2 = _ref.getWidgetDescriptors,
    getCommonDescriptors$2 = _ref.getCommonDescriptors;

var scan = applySpec({
  commonDescriptors: getCommonDescriptors$2,
  widgetDescriptors: getWidgetDescriptors$2
});

var invariant = function invariant(pred, msg) {
  if (pred) {
    return;
  }

  if (SHOULD_NOT_LEAK) {
    throw new Error('An error occurred. Use a non-production build to see the details.');
  }

  throw new Error(msg);
};
var getDisplayName = function getDisplayName(Component) {
  return Component.displayName || Component.name || 'Component';
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var mergeData = ifElse(contains(INVALID_JSON), always(INVALID_JSON), o(mergeDeepRightAll, rejectNil));

var findRouteByDescriptor = function findRouteByDescriptor(routes, descriptor) {
  return find(whereEq({
    path: descriptor.widget
  }), routes);
};

var findComponentByDescriptor = function findComponentByDescriptor(routes, descriptor) {
  var route = findRouteByDescriptor(routes, descriptor);
  invariant(route, "Missing route for widget name " + descriptor.widget + ".");
  return route.component;
};

var makeWidgetConfig = curry(function (routes, commonData, descriptor) {
  return _objectSpread$1({}, descriptor, {
    component: findComponentByDescriptor(routes, descriptor),
    data: mergeData([commonData, descriptor.data]),
    namespace: descriptor.namespace || descriptor.container
  });
});
var getCommonData = o(mergeData, map(prop('data')));

var route = function route(routes, scanResult) {
  var commonDescriptors = scanResult.commonDescriptors,
      widgetDescriptors = scanResult.widgetDescriptors;
  var commonData = getCommonData(commonDescriptors);
  invariant(commonData !== INVALID_JSON, 'Invalid JSON data encountered in a common descriptor. ' + 'This is often due to a trailing comma or missing quotation marks.');
  var widgetConfigs = map(makeWidgetConfig(routes, commonData), widgetDescriptors);
  return {
    commonData: commonData,
    widgetConfigs: widgetConfigs,
    scanResult: scanResult,
    routes: routes
  };
};

var getWidgetName = path(['props', 'config', 'widget']);

var withErrorBoundary = function withErrorBoundary(NextComponent) {
  var WithErrorBoundary =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(WithErrorBoundary, _Component);

    function WithErrorBoundary() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Component.call.apply(_Component, [this].concat(args)) || this;
      _this.state = {
        hasError: false
      };
      return _this;
    }

    var _proto = WithErrorBoundary.prototype;

    _proto.componentDidCatch = function componentDidCatch() {
      this.setState({
        hasError: true
      });
    };

    _proto.render = function render() {
      var hasError = this.state.hasError;
      var widgetName = getWidgetName(this);

      if (hasError) {
        return React.createElement("div", null, "An error has occurred in widget \"" + widgetName + "\". See the console for more details. To\n\t\t\t\t\t\tavoid seeing this message in production, wrap this widget in an error boundary.");
      }

      return React.createElement(NextComponent, this.props);
    };

    return WithErrorBoundary;
  }(Component);

  WithErrorBoundary.displayName = "WithErrorBoundary(" + getDisplayName(NextComponent) + ")";
  WithErrorBoundary.propTypes = {
    config: PropTypes.shape(WidgetConfigShape).isRequired
  };
  return WithErrorBoundary;
};

var makeContextDecorator = function makeContextDecorator(Context, displayName) {
  return function (NextComponent) {
    var Decorator = function Decorator(props) {
      return React.createElement(Context.Consumer, null, function (value) {
        return React.createElement(NextComponent, _extends({}, value, props));
      });
    };

    hoistNonReactStatics(Decorator, NextComponent);
    Decorator.displayName = "With" + displayName + "(" + getDisplayName(NextComponent) + ")";
    return Decorator;
  };
};
var withWidgetContext = makeContextDecorator(WidgetContext, 'WidgetContext');

var getGlobalInitialProps = function getGlobalInitialProps(props) {
  return !IS_SERVER && window.__INITIAL_PROPS__ && window.__INITIAL_PROPS__[props.config.namespace];
};

var memoizedClearContent = memoizeWith(prop('id'), function (element) {
  return element.innerHTML = '';
});
/**
 * An internal component of `Union`.
 *
 * It renders a widget based on `descriptor` and `component` using React portals.
 * Provides context to the `component` with widget descriptor information.
 *
 */

var Widget =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Widget, _Component);

  function Widget(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;

    _this.getInitialProps = function (component) {
      var config = _this.props.config;

      if (isFunction(component.getInitialProps)) {
        component.getInitialProps(config).then(function (initialProps) {
          return _this.setState({
            initialProps: initialProps
          });
        });
      }
    };

    _this.state = {
      initialProps: props.initialProps || getGlobalInitialProps(props) || null
    };
    return _this;
  } // NOTE: We do not use an async function to avoid bundle size issues with regenerator runtime.


  var _proto = Widget.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var initialProps = this.state.initialProps;

    if (!initialProps) {
      var config = this.props.config;
      var component = config.component;

      if (isFunction(component.preload)) {
        return component.preload().then(this.getInitialProps);
      }

      this.getInitialProps(component);
    }
  };

  _proto.render = function render() {
    var config = this.props.config;
    var initialProps = this.state.initialProps;
    var WidgetComponent = config.component,
        container = config.container,
        data = config.data,
        namespace = config.namespace,
        widget = config.widget;
    invariant(data !== INVALID_JSON, "Invalid JSON data encountered while attempting to render widget \"" + widget + "\". " + 'This is often due to a trailing comma or missing quotation marks.');
    var widgetProps = {
      data: data,
      namespace: namespace
    };
    var widgetElement = React.createElement(WidgetContext.Provider, {
      value: widgetProps
    }, React.createElement(WidgetComponent, _extends({}, widgetProps, initialProps)));

    if (IS_SERVER) {
      return React.createElement("div", {
        "data-union-portal": container
      }, widgetElement);
    }

    var domElement = document.getElementById(container);
    invariant(domElement, "HTML element with ID \"" + container + "\" not found for widget \"" + widget + "\"."); // NOTE: Because React does not support hydration of portals yet, we clear the domElement's
    // inner HTML on the initial render. In order to prevent an ugly white flash, we need to do
    // this immediately before rendering the actual client-side portal. Memoization is used
    // to prevent clearing the same element more than once per multiple client-side renders.
    // TODO: Remove next line when https://github.com/facebook/react/issues/13097 is resolved.

    memoizedClearContent(domElement);
    return createPortal(widgetElement, domElement);
  };

  return Widget;
}(Component);
Widget.propTypes = {
  config: PropTypes.shape(WidgetConfigShape).isRequired,
  initialProps: PropTypes.object
};
var Widget$1 = withErrorBoundary(Widget);

/**
 * Renders your widgets according to found widget descriptors and passed `routes`.
 * Widgets are encapsulated in a single virtual DOM even though they may be spread out
 * in the actual mark-up.
 */

var Union =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Union, _Component);

  Union.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, previousState) {
    if (previousState.routesReference !== nextProps.routes) {
      return {
        routesReference: nextProps.routes,
        widgetConfigs: Union.scan(nextProps)
      };
    }

    return null;
  };

  function Union(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;

    _this.rescan = function () {
      return _this.setState({
        widgetConfigs: Union.scan(_this.props)
      });
    };

    _this.renderWidget = function (widgetConfig) {
      var _ref = _this.context || {},
          initialProps = _ref.initialProps;

      return React.createElement(Widget$1, {
        config: widgetConfig,
        initialProps: path([widgetConfig.namespace], initialProps),
        key: widgetConfig.namespace
      });
    };

    var _ref2 = _this.context || {},
        widgetConfigs = _ref2.widgetConfigs;

    _this.state = {
      routesReference: props.routes,
      widgetConfigs: widgetConfigs || Union.scan(props)
    };
    return _this;
  }

  var _proto = Union.prototype;

  _proto.componentDidMount = function componentDidMount() {
    document.addEventListener(RESCAN, this.rescan);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    document.removeEventListener(RESCAN, this.rescan);
  };

  _proto.render = function render() {
    var children = this.props.children;
    var widgetConfigs = this.state.widgetConfigs;
    return React.createElement(Fragment, null, children, map(this.renderWidget, widgetConfigs));
  };

  return Union;
}(Component);

Union.scan = function (props) {
  var onScanStart = props.onScanStart,
      onScanEnd = props.onScanEnd,
      onScanError = props.onScanError,
      parent = props.parent,
      routes = props.routes;
  invariant(routes, 'Missing `routes` prop in <Union />.');

  try {
    onScanStart();
    var scanResult = scan(parent);
    var routeResult = route(routes, scanResult);
    onScanEnd(routeResult);
    return routeResult.widgetConfigs;
  } catch (error) {
    onScanError(error);
    throw error;
  }
};

Union.propTypes = {
  /**
   * Children of the `Union` component.
   */
  children: PropTypes.node,

  /**
   * Called after the scan of the HTML is successfully done.
   */
  onScanEnd: PropTypes.func,

  /**
   * Called when an error happens while scanning the HTML.
   */
  onScanError: PropTypes.func,

  /**
   * Called before the scan of the HTML.
   */
  onScanStart: PropTypes.func,

  /**
   * HTML element or Cheerio wrapper in which the scan is running. Defaults to `document`.
   */
  parent: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),

  /**
   * Array of routes that are supported by your application.
   */
  routes: PropTypes.arrayOf(PropTypes.shape(RouteShape))
};
Union.defaultProps = {
  onScanEnd: noop,
  onScanError: noop,
  onScanStart: noop,
  parent: IS_SERVER ? null : document
};
Union.contextType = PrescanContext;

export { PrescanContext, RouteShape, Union, WidgetConfigShape, WidgetContext, WidgetDescriptorShape, justRender, justUnmountComponentAtNode, rescan, route, scan, withWidgetContext };
