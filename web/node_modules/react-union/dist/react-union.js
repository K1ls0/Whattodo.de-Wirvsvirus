(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('prop-types'), require('react-dom'), require('ramda-extension'), require('react'), require('ramda')) :
typeof define === 'function' && define.amd ? define(['exports', 'prop-types', 'react-dom', 'ramda-extension', 'react', 'ramda'], factory) :
(global = global || self, factory(global.ReactUnion = {}, global.PropTypes, global.ReactDOM, global.R_, global.React, global.R));
}(this, function (exports, PropTypes, ReactDOM, ramdaExtension, React, ramda) { 'use strict';

PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
var ReactDOM__default = 'default' in ReactDOM ? ReactDOM['default'] : ReactDOM;
var React__default = 'default' in React ? React['default'] : React;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var RouteShape = {
  component: PropTypes.elementType.isRequired,
  path: PropTypes.string.isRequired
};
var WidgetDescriptorShape = {
  container: PropTypes.string,
  data: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  namespace: PropTypes.string,
  widget: PropTypes.string.isRequired
};
var WidgetConfigShape = _objectSpread({}, WidgetDescriptorShape, {
  component: PropTypes.elementType.isRequired,
  // NOTE: We added `isRequired` to avoid using `namespace || container` everywhere.
  namespace: PropTypes.string.isRequired
});

var INVALID_JSON = 'INVALID_JSON';
var IS_SERVER = Boolean(process && process.versions && process.versions.node);
var RESCAN = 'react-union/rescan';

var DEFAULT_UNION_ROOT_ID = 'union';

var createElement = function createElement(id, parent, elementType) {
  var newElement = document.createElement(elementType);
  var idAttribute = document.createAttribute('id');
  idAttribute.value = id;
  newElement.setAttributeNode(idAttribute);
  parent.appendChild(newElement);
  return newElement;
};

var createElementWithId = function createElementWithId(id, parent, elementType) {
  if (elementType === void 0) {
    elementType = 'div';
  }

  var element = document.getElementById(id);
  return element ? element : createElement(id, parent, elementType);
};

function justRender(reactElement, rootId, resolve) {
  if (rootId === void 0) {
    rootId = DEFAULT_UNION_ROOT_ID;
  }

  if (resolve === void 0) {
    resolve = ramdaExtension.noop;
  }

  var domElement = createElementWithId(rootId, document.body);

  if (window.__HYDRATE__) {
    // NOTE: We do not want to hydrate twice.
    delete window.__HYDRATE__; // TODO: Use ReactDOM.hydrate once React supports hydration of portals.
    // https://github.com/facebook/react/issues/13097

    ReactDOM__default.render(reactElement, domElement, resolve);
  }

  ReactDOM__default.render(reactElement, domElement, resolve);
}
function justUnmountComponentAtNode(rootId) {
  if (rootId === void 0) {
    rootId = DEFAULT_UNION_ROOT_ID;
  }

  var rootElement = document.getElementById(rootId);
  ReactDOM__default.unmountComponentAtNode(rootElement);
}
var rescan = function rescan() {
  var event = document.createEvent('Event');
  event.initEvent(RESCAN, true, true);
  document.dispatchEvent(event);
};

var WidgetContext = React.createContext({
  data: undefined,
  namespace: undefined
});
var PrescanContext = React.createContext({
  initialProps: undefined,
  widgetConfigs: undefined
});

var selectWidgetDescriptorElements = function selectWidgetDescriptorElements(parent) {
  return parent.querySelectorAll('[data-union-widget]');
};

var selectCommonDescriptorElements = function selectCommonDescriptorElements(parent) {
  return parent.querySelectorAll('[data-union-common]');
};

var dangerouslyParseJSONContent = ramda.o(ramda.unary(JSON.parse), ramda.prop('innerHTML'));

var parseJSONContent = function parseJSONContent(element) {
  try {
    return dangerouslyParseJSONContent(element);
  } catch (error) {
    if (element.innerHTML.trim()) {
      return INVALID_JSON;
    }

    return null;
  }
};

var parseWidgetDescriptorElement = ramda.applySpec({
  widget: ramda.path(['dataset', 'unionWidget']),
  container: ramda.path(['dataset', 'unionContainer']),
  namespace: ramda.path(['dataset', 'unionNamespace']),
  data: parseJSONContent
});
var getWidgetDescriptors = ramda.o(ramda.map(parseWidgetDescriptorElement), selectWidgetDescriptorElements);
var parseCommonDescriptorElement = ramda.applySpec({
  data: parseJSONContent
});
var getCommonDescriptors = ramda.o(ramda.map(parseCommonDescriptorElement), selectCommonDescriptorElements);

var DOM = /*#__PURE__*/Object.freeze({
getWidgetDescriptors: getWidgetDescriptors,
getCommonDescriptors: getCommonDescriptors
});

var dangerouslyParseJSONContent$1 = ramda.o(ramda.unary(JSON.parse), function (wrapper) {
  return wrapper.html();
});

var parseJSONContent$1 = function parseJSONContent(wrapper) {
  try {
    return dangerouslyParseJSONContent$1(wrapper);
  } catch (error) {
    if (wrapper.html().trim()) {
      return INVALID_JSON;
    }

    return null;
  }
};

var parseWidgetDescriptorWrapper = function parseWidgetDescriptorWrapper(wrapper) {
  return {
    widget: wrapper.data('union-widget'),
    container: wrapper.data('union-container'),
    namespace: wrapper.data('union-namespace'),
    data: parseJSONContent$1(wrapper)
  };
};

var getWidgetDescriptors$1 = function getWidgetDescriptors($) {
  return $('[data-union-widget]').map(function (_, element) {
    return parseWidgetDescriptorWrapper($(element));
  }).get();
};
var parseCommonDescriptorWrapper = ramda.applySpec({
  data: parseJSONContent$1
});
var getCommonDescriptors$1 = function getCommonDescriptors($) {
  return $('[data-union-common]').map(function (_, element) {
    return parseCommonDescriptorWrapper($(element));
  }).get();
};

var Cheerio = /*#__PURE__*/Object.freeze({
getWidgetDescriptors: getWidgetDescriptors$1,
getCommonDescriptors: getCommonDescriptors$1
});

var _ref = IS_SERVER ? Cheerio : DOM,
    getWidgetDescriptors$2 = _ref.getWidgetDescriptors,
    getCommonDescriptors$2 = _ref.getCommonDescriptors;

var scan = ramda.applySpec({
  commonDescriptors: getCommonDescriptors$2,
  widgetDescriptors: getWidgetDescriptors$2
});

var invariant = function invariant(pred, msg) {
  if (pred) {
    return;
  }

  throw new Error(msg);
};
var getDisplayName = function getDisplayName(Component) {
  return Component.displayName || Component.name || 'Component';
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var mergeData = ramda.ifElse(ramda.contains(INVALID_JSON), ramda.always(INVALID_JSON), ramda.o(ramdaExtension.mergeDeepRightAll, ramdaExtension.rejectNil));

var findRouteByDescriptor = function findRouteByDescriptor(routes, descriptor) {
  return ramda.find(ramda.whereEq({
    path: descriptor.widget
  }), routes);
};

var findComponentByDescriptor = function findComponentByDescriptor(routes, descriptor) {
  var route = findRouteByDescriptor(routes, descriptor);
  invariant(route, "Missing route for widget name " + descriptor.widget + ".");
  return route.component;
};

var makeWidgetConfig = ramda.curry(function (routes, commonData, descriptor) {
  return _objectSpread$1({}, descriptor, {
    component: findComponentByDescriptor(routes, descriptor),
    data: mergeData([commonData, descriptor.data]),
    namespace: descriptor.namespace || descriptor.container
  });
});
var getCommonData = ramda.o(mergeData, ramda.map(ramda.prop('data')));

var route = function route(routes, scanResult) {
  var commonDescriptors = scanResult.commonDescriptors,
      widgetDescriptors = scanResult.widgetDescriptors;
  var commonData = getCommonData(commonDescriptors);
  invariant(commonData !== INVALID_JSON, 'Invalid JSON data encountered in a common descriptor. ' + 'This is often due to a trailing comma or missing quotation marks.');
  var widgetConfigs = ramda.map(makeWidgetConfig(routes, commonData), widgetDescriptors);
  return {
    commonData: commonData,
    widgetConfigs: widgetConfigs,
    scanResult: scanResult,
    routes: routes
  };
};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

var reactIs_development = createCommonjsModule(function (module, exports) {

{
  (function () {

    Object.defineProperty(exports, '__esModule', {
      value: true
    }); // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?

    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE);
    }
    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */


    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });

        if (typeof console !== 'undefined') {
          console.warn(message);
        }

        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
        }

        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }
    var lowPriorityWarning$1 = lowPriorityWarning;

    function typeOf(object) {
      if (typeof object === 'object' && object !== null) {
        var $$typeof = object.$$typeof;

        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;

            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;

              default:
                var $$typeofType = type && type.$$typeof;

                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;

                  default:
                    return $$typeof;
                }

            }

          case REACT_LAZY_TYPE:
          case REACT_MEMO_TYPE:
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }

      return undefined;
    } // AsyncMode is deprecated along with isAsyncMode


    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

    function isAsyncMode(object) {
      {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
          hasWarnedAboutDeprecatedIsAsyncMode = true;
          lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
        }
      }
      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }

    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }

    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }

    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }

    function isElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }

    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }

    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }

    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }

    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }

    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }

    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }

    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }

    exports.typeOf = typeOf;
    exports.AsyncMode = AsyncMode;
    exports.ConcurrentMode = ConcurrentMode;
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isValidElementType = isValidElementType;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
  })();
}
});

unwrapExports(reactIs_development);
var reactIs_development_1 = reactIs_development.typeOf;
var reactIs_development_2 = reactIs_development.AsyncMode;
var reactIs_development_3 = reactIs_development.ConcurrentMode;
var reactIs_development_4 = reactIs_development.ContextConsumer;
var reactIs_development_5 = reactIs_development.ContextProvider;
var reactIs_development_6 = reactIs_development.Element;
var reactIs_development_7 = reactIs_development.ForwardRef;
var reactIs_development_8 = reactIs_development.Fragment;
var reactIs_development_9 = reactIs_development.Lazy;
var reactIs_development_10 = reactIs_development.Memo;
var reactIs_development_11 = reactIs_development.Portal;
var reactIs_development_12 = reactIs_development.Profiler;
var reactIs_development_13 = reactIs_development.StrictMode;
var reactIs_development_14 = reactIs_development.Suspense;
var reactIs_development_15 = reactIs_development.isValidElementType;
var reactIs_development_16 = reactIs_development.isAsyncMode;
var reactIs_development_17 = reactIs_development.isConcurrentMode;
var reactIs_development_18 = reactIs_development.isContextConsumer;
var reactIs_development_19 = reactIs_development.isContextProvider;
var reactIs_development_20 = reactIs_development.isElement;
var reactIs_development_21 = reactIs_development.isForwardRef;
var reactIs_development_22 = reactIs_development.isFragment;
var reactIs_development_23 = reactIs_development.isLazy;
var reactIs_development_24 = reactIs_development.isMemo;
var reactIs_development_25 = reactIs_development.isPortal;
var reactIs_development_26 = reactIs_development.isProfiler;
var reactIs_development_27 = reactIs_development.isStrictMode;
var reactIs_development_28 = reactIs_development.isSuspense;

var reactIs = createCommonjsModule(function (module) {

{
  module.exports = reactIs_development;
}
});

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */



var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;

function getStatics(component) {
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  }

  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty$1 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty$1(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }

    return targetComponent;
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var inheritsLoose = _inheritsLoose;

var getWidgetName = ramda.path(['props', 'config', 'widget']);

var withErrorBoundary = function withErrorBoundary(NextComponent) {
  var WithErrorBoundary =
  /*#__PURE__*/
  function (_Component) {
    inheritsLoose(WithErrorBoundary, _Component);

    function WithErrorBoundary() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Component.call.apply(_Component, [this].concat(args)) || this;
      _this.state = {
        hasError: false
      };
      return _this;
    }

    var _proto = WithErrorBoundary.prototype;

    _proto.componentDidCatch = function componentDidCatch() {
      this.setState({
        hasError: true
      });
    };

    _proto.render = function render() {
      var hasError = this.state.hasError;
      var widgetName = getWidgetName(this);

      if (hasError) {
        return React__default.createElement("div", null, "An error has occurred in widget \"" + widgetName + "\". See the console for more details. To\n\t\t\t\t\t\tavoid seeing this message in production, wrap this widget in an error boundary.");
      }

      return React__default.createElement(NextComponent, this.props);
    };

    return WithErrorBoundary;
  }(React.Component);

  WithErrorBoundary.displayName = "WithErrorBoundary(" + getDisplayName(NextComponent) + ")";
  WithErrorBoundary.propTypes = {
    config: PropTypes.shape(WidgetConfigShape).isRequired
  };
  return WithErrorBoundary;
};

var makeContextDecorator = function makeContextDecorator(Context, displayName) {
  return function (NextComponent) {
    var Decorator = function Decorator(props) {
      return React__default.createElement(Context.Consumer, null, function (value) {
        return React__default.createElement(NextComponent, _extends_1({}, value, props));
      });
    };

    hoistNonReactStatics_cjs(Decorator, NextComponent);
    Decorator.displayName = "With" + displayName + "(" + getDisplayName(NextComponent) + ")";
    return Decorator;
  };
};
var withWidgetContext = makeContextDecorator(WidgetContext, 'WidgetContext');

var getGlobalInitialProps = function getGlobalInitialProps(props) {
  return !IS_SERVER && window.__INITIAL_PROPS__ && window.__INITIAL_PROPS__[props.config.namespace];
};

var memoizedClearContent = ramda.memoizeWith(ramda.prop('id'), function (element) {
  return element.innerHTML = '';
});
/**
 * An internal component of `Union`.
 *
 * It renders a widget based on `descriptor` and `component` using React portals.
 * Provides context to the `component` with widget descriptor information.
 *
 */

var Widget =
/*#__PURE__*/
function (_Component) {
  inheritsLoose(Widget, _Component);

  function Widget(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;

    _this.getInitialProps = function (component) {
      var config = _this.props.config;

      if (ramdaExtension.isFunction(component.getInitialProps)) {
        component.getInitialProps(config).then(function (initialProps) {
          return _this.setState({
            initialProps: initialProps
          });
        });
      }
    };

    _this.state = {
      initialProps: props.initialProps || getGlobalInitialProps(props) || null
    };
    return _this;
  } // NOTE: We do not use an async function to avoid bundle size issues with regenerator runtime.


  var _proto = Widget.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var initialProps = this.state.initialProps;

    if (!initialProps) {
      var config = this.props.config;
      var component = config.component;

      if (ramdaExtension.isFunction(component.preload)) {
        return component.preload().then(this.getInitialProps);
      }

      this.getInitialProps(component);
    }
  };

  _proto.render = function render() {
    var config = this.props.config;
    var initialProps = this.state.initialProps;
    var WidgetComponent = config.component,
        container = config.container,
        data = config.data,
        namespace = config.namespace,
        widget = config.widget;
    invariant(data !== INVALID_JSON, "Invalid JSON data encountered while attempting to render widget \"" + widget + "\". " + 'This is often due to a trailing comma or missing quotation marks.');
    var widgetProps = {
      data: data,
      namespace: namespace
    };
    var widgetElement = React__default.createElement(WidgetContext.Provider, {
      value: widgetProps
    }, React__default.createElement(WidgetComponent, _extends_1({}, widgetProps, initialProps)));

    if (IS_SERVER) {
      return React__default.createElement("div", {
        "data-union-portal": container
      }, widgetElement);
    }

    var domElement = document.getElementById(container);
    invariant(domElement, "HTML element with ID \"" + container + "\" not found for widget \"" + widget + "\"."); // NOTE: Because React does not support hydration of portals yet, we clear the domElement's
    // inner HTML on the initial render. In order to prevent an ugly white flash, we need to do
    // this immediately before rendering the actual client-side portal. Memoization is used
    // to prevent clearing the same element more than once per multiple client-side renders.
    // TODO: Remove next line when https://github.com/facebook/react/issues/13097 is resolved.

    memoizedClearContent(domElement);
    return ReactDOM.createPortal(widgetElement, domElement);
  };

  return Widget;
}(React.Component);
Widget.propTypes = {
  config: PropTypes.shape(WidgetConfigShape).isRequired,
  initialProps: PropTypes.object
};
var Widget$1 = withErrorBoundary(Widget);

/**
 * Renders your widgets according to found widget descriptors and passed `routes`.
 * Widgets are encapsulated in a single virtual DOM even though they may be spread out
 * in the actual mark-up.
 */

var Union =
/*#__PURE__*/
function (_Component) {
  inheritsLoose(Union, _Component);

  Union.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, previousState) {
    if (previousState.routesReference !== nextProps.routes) {
      return {
        routesReference: nextProps.routes,
        widgetConfigs: Union.scan(nextProps)
      };
    }

    return null;
  };

  function Union(props, context) {
    var _this;

    _this = _Component.call(this, props, context) || this;

    _this.rescan = function () {
      return _this.setState({
        widgetConfigs: Union.scan(_this.props)
      });
    };

    _this.renderWidget = function (widgetConfig) {
      var _ref = _this.context || {},
          initialProps = _ref.initialProps;

      return React__default.createElement(Widget$1, {
        config: widgetConfig,
        initialProps: ramda.path([widgetConfig.namespace], initialProps),
        key: widgetConfig.namespace
      });
    };

    var _ref2 = _this.context || {},
        widgetConfigs = _ref2.widgetConfigs;

    _this.state = {
      routesReference: props.routes,
      widgetConfigs: widgetConfigs || Union.scan(props)
    };
    return _this;
  }

  var _proto = Union.prototype;

  _proto.componentDidMount = function componentDidMount() {
    document.addEventListener(RESCAN, this.rescan);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    document.removeEventListener(RESCAN, this.rescan);
  };

  _proto.render = function render() {
    var children = this.props.children;
    var widgetConfigs = this.state.widgetConfigs;
    return React__default.createElement(React.Fragment, null, children, ramda.map(this.renderWidget, widgetConfigs));
  };

  return Union;
}(React.Component);

Union.scan = function (props) {
  var onScanStart = props.onScanStart,
      onScanEnd = props.onScanEnd,
      onScanError = props.onScanError,
      parent = props.parent,
      routes = props.routes;
  invariant(routes, 'Missing `routes` prop in <Union />.');

  try {
    onScanStart();
    var scanResult = scan(parent);
    var routeResult = route(routes, scanResult);
    onScanEnd(routeResult);
    return routeResult.widgetConfigs;
  } catch (error) {
    onScanError(error);
    throw error;
  }
};

Union.propTypes = {
  /**
   * Children of the `Union` component.
   */
  children: PropTypes.node,

  /**
   * Called after the scan of the HTML is successfully done.
   */
  onScanEnd: PropTypes.func,

  /**
   * Called when an error happens while scanning the HTML.
   */
  onScanError: PropTypes.func,

  /**
   * Called before the scan of the HTML.
   */
  onScanStart: PropTypes.func,

  /**
   * HTML element or Cheerio wrapper in which the scan is running. Defaults to `document`.
   */
  parent: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),

  /**
   * Array of routes that are supported by your application.
   */
  routes: PropTypes.arrayOf(PropTypes.shape(RouteShape))
};
Union.defaultProps = {
  onScanEnd: ramdaExtension.noop,
  onScanError: ramdaExtension.noop,
  onScanStart: ramdaExtension.noop,
  parent: IS_SERVER ? null : document
};
Union.contextType = PrescanContext;

exports.PrescanContext = PrescanContext;
exports.RouteShape = RouteShape;
exports.Union = Union;
exports.WidgetConfigShape = WidgetConfigShape;
exports.WidgetContext = WidgetContext;
exports.WidgetDescriptorShape = WidgetDescriptorShape;
exports.justRender = justRender;
exports.justUnmountComponentAtNode = justUnmountComponentAtNode;
exports.rescan = rescan;
exports.route = route;
exports.scan = scan;
exports.withWidgetContext = withWidgetContext;

Object.defineProperty(exports, '__esModule', { value: true });

}));
