import { compose, filter, identity, when, anyPass, flatten, values, mapObjIndexed, map, into } from 'ramda';
import flattenArgs from './flattenArgs';
import joinWithSpace from './joinWithSpace';
import isObject from './isObject';
import isString from './isString';
import isNumber from './isNumber';
var filterFalsy = /*#__PURE__*/filter(identity);
var keepObjectStringNumber = /*#__PURE__*/filter( /*#__PURE__*/anyPass([isObject, isString, isNumber]));
var keepKeyIfValueIsTruthy = /*#__PURE__*/mapObjIndexed(function (v, k) {
  return v && k;
});
var destructObject = /*#__PURE__*/compose(filterFalsy, values, keepKeyIfValueIsTruthy);
var transduceArgs = /*#__PURE__*/into([], /*#__PURE__*/compose( /*#__PURE__*/map( /*#__PURE__*/when(isObject, destructObject)), keepObjectStringNumber, filterFalsy));
/**
 * Conditionally joining classNames together.
 *
 * The cx function takes any number of arguments which can be a string, object
 * even nested arrays of strings and objects.
 *
 * The argument 'foo' is short for { foo: true }.
 *
 * If the value associated with a given key is falsy, that key won't be included in the output.
 *
 * @func
 * @category String
 *
 * @example
 *
 *        R_.cx('Table', ['MagicTable'], {'Table--active': true })	// 'Table MagicTable Table--active'
 *        R_.cx('Table', ['MagicTable'], {'Table--active': false })	// 'Table MagicTable'
 *        R_.cx(['Table', ['MagicTable']])				// 'Table MagicTable'
 *
 * @sig String | [String] | Object -> String
 */

var cx = /*#__PURE__*/compose(joinWithSpace, flatten, transduceArgs, flattenArgs);
export default cx;